\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[lined,algonl,boxed]{algorithm2e}


\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}




\title{ELEN4020: Data Intensive Computing\\ Lab 3\\
{\footnotesize School of Electrical \& Information Engineering, University of the
Witwatersrand, Private Bag 3, 2050, Johannesburg, South Africa}
%\thanks{Identify applicable funding agency here. If none, delete this.}
}


\author{

\IEEEauthorblockN{Elias Sepuru 1427726}
\and
\IEEEauthorblockN{Boikanyo Radiokana 1386807}
\and
\IEEEauthorblockN{Lloyd Patsika 1041888}

}

\maketitle

\section{INTRODUCTION}
In this report, the MapReduce framework is used to count the occurrence of each word in a text file. On top of finding the occurrence of each word, the top K, where K=10,20, occurring words are distinguished. The framework is also used to find the indices of words in a text file. The time taken to count the occurrences of each word in a text file and the indices the words appear on are recorded. Mrs-MapReduce, a lightweight implementation of MapReduce is used. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\section{DESIGN \& IMPLEMENTATION}
This lab is divided into three sections, the basic WordCount hello world, topK query and the inverted index of text.

\subsection{Hello World: WordCount}
The basic WordCount implementation involves obtaining words from a text file which are then assigned to a value, which is the number of times it occurs in the text file. The output text file simply sorts the words in alphabetical order and also shows the value. The role of the map function is to assign a word, the key, to an initial value of 1. In order for the mapping to occur, the program first checks whether the word is not one of the stop words. Stop words are located in a separate file and are not included in any mapping. The reduce function then aims to find identical keys from the mappings and add their values in order to obtain the final count for each word. The implementation of the WordCount algorithm is presented in algorithm \ref{1}.
\\
\begin{algorithm}[h!]

\centring

\SetKwData{in}{in}
\SetKwData{not}{not}
\SetKwData{st}{\texttt{StopWords}}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFunction{wi}{WordIndex(mrs.MapReduce)}
\SetKwFunction{red}{reduce(word,line\_num)}
\SetKwFunction{redu}{reduce(word,counts)}
\SetKwFunction{sum}{sum(counts)}
\SetKwFunction{map}{map(line\_num, line\_text)}


\caption{\texttt{BasicWordCount(mrs.MapReduce)}: Hello World and Stop Words}\Input{A text file and the directory of where the output file is going to be saved, all from the terminal}
\Output{Text file containing words with the number of times they occur}
\vspace{0.5cm}

\map:
   
 \For{word \in Apostrophe.findall(line_lext):}
        {{word$\leftarrow$word.strip(string.punctuation).lower()}}
        \If{word.lower() \not \in \st:}{
            \If{word:}{
                yield (word,1)}}
        

\vspace{0.5cm}
\redu\\


    yield \sum
%\For{$i\gets1$ \KwTo $n$}{

%     \For{$j\gets1$ \KwTo $n$}{

%	\For{$k\gets1$ \KWTo $n$}{

%	     \tempSum$\leftarrow$ \tempSum + {$A[i,k]\times B[j,k]$}\;
%	}
%	\tempVector$\leftarrow$ \tempSum\;
%}

%\C$\leftarrow$ \tempVector\;

%}
%\Return \C
\label{1}
\end{algorithm}

\subsection{TopK Query}
The topK query implementation involves finding the top 10 and 20 words that appear the most in a text file. It is achieved through the use of two functions, \texttt{SortInDesc} and \texttt{TopKQuery}. The \texttt{SortInDesc} uses an array to sort the words and frequencies in descending order by continuously sorting every time a word is read from a file. After sorting the words in descending order only the top 10 and 20 entries of the array are written to two different files respectively. The sorting function is called in the \texttt{reduce} function so that it continuously sorts the array as a word and its total frequency is generated by the \texttt{reduce} function. Algorithm\ref{2} illustrates how the two functions were implemented:
\linesnumbered
\begin{algorithm}[h!]

\centring

\SetKwData{in}{in}
\SetKwData{not}{not}
\SetKwData{num}{num}
\SetKwData{top10}{top10}
\SetKwData{top20}{top20}
\SetKwData{st}{\texttt{StopWords}}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFunction{wi}{WordIndex(mrs.MapReduce)}
\SetKwFunction{red}{reduce(word,line\_num)}
\SetKwFunction{SortInDesc}{SortInDesc(word, counts)}
\SetKwFunction{TopKQuery}{TopKQuery(lines)}

\caption{\texttt{SortInDesc} and \texttt{TopKQuery} }\Input{A text file and the directory of where the output file is going to be saved, all from the terminal}
\Output{Two text files containing the top 10 and top 20 words respectively}
\vspace{0.5cm}

\SortInDesc:

words$\leftarrow$open("SortedWords.txt","append")\\
write word and counts to words\\
words.close()\\
\vspace{0.25cm}
open SortedWords.txt as textFile:\\
    lines$\leftarrow$lines.split() for line in textFile\\
    sort lines in descending order\\
TopKQuery(lines)\\
words.close()\\
num$\leftarrow$0\\
\vspace{0.5cm}
\TopKQuery:

top10$\leftarrow$open("top10_.txt", "w")\\
top20$\leftarrow$open("top20_.txt", "w")\\
 \For{i \in lines}{
 
        \If{ num $<$ 20}{
            \If{num $<$ 10}{
                top10.write(i[0] +" "+ i[1] + "\n")
            }
            top20.write(i[0] +" "+ i[1] + "\n")\\
            num = num+1
        
        }
                
  }
top10.close() \\
top20.close()
        
\label{2}
\end{algorithm}


\subsection{Inverted Index}
The inverted index text involves returning the lines that each word in a text file resides on. The number of lines returned are restricted to 50. The inverted index program is created using Mrs-MapReduce. The following algorithm shown in algorithm \ref{ii} is used to perform the inverted index task.
\linesnumbered
\begin{algorithm}[h!]

\centring

\SetKwData{in}{in}
\SetKwData{not}{not}
\SetKwData{st}{\texttt{StopWords}}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\SetKwFunction{wi}{WordIndex(mrs.MapReduce)}
\SetKwFunction{red}{reduce(word,line\_num)}
\SetKwFunction{map}{map(line\_num, line\_text)}


\caption{\texttt{WordIndex(mrs.MapReduce)}: Inverted text code}\Input{A text file and the directory of where the output file is going to be saved, all from the terminal}
\Output{Text file containing words with indices}
\vspace{0.5cm}

\map:
   
 \For{word \in line\_text.split():}
        {{word $\leftarrow$ word.strip(string.punctuation).lower()}}
        \If{word \not \in \st and \not word[0].isdigit()}{
         yield (word, line\_num + 1)}

\vspace{0.5cm}
\red\\
 lineNumbers $\leftarrow$ []
 
        \For{ i \in line\_num}{
            \If{ len(lineNumbers) $>=$ 50}
                {break}
            \If{i \not in lineNumbers}{
                lineNumbers.append(i)}
            }
    yield lineNumbers
\label{ii}
\end{algorithm}

The \texttt{map} function works the same way as described in the previous sub-section, the only difference is that it returns the word and its line number instead of the number 1. In the \texttt{reduce} function the line numbers corresponding to each word are appended to a single array, the if statements guard to ensure that no line numbers are repeated and to ensure that no more than 50 line numbers are returned.

\section{RESULTS}
The three programs Simple WordCount, TopK Query and Inverted index are run serially and then later with Mrs-Mapreduce dividing the job into tasks and giving it to slaves. Table \ref{results} presents the run times for each program for running serially and using Map-Reduce.

\begin{table}[h!]
\centering
\caption{Time taken to run program}
\label{results}
\begin{tabular}{|c|c|l|}
\hline
\textbf{Program} & \textbf{\begin{tabular}[c]{@{}c@{}}File1ForLab3.txt\\time(s)\end{tabular}} & \multicolumn{1}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}File2ForLab3.txt\\time(s)\end{tabular}}} \\ \hline
\begin{tabular}[c]{@{}c@{}}Simple\\ WordCount\end{tabular} & 0.54324 & 7.10453 \\ \hline
TopK Query & 13.65718 & 71.53241 \\ \hline
Inverted Index & 1.104700 & 5.16014 \\ \hline
\end{tabular}
\end{table}

Unfortunately the Hadoop setup always gave errors when running the master and slaves, for some odd reason the program was complaining that the slaves and master are not running the same programm. It gave out the following error : \textit{WARNING: Slave tried to sign in with non matching code}. So the the three programs were never ran using Hadoop, only serially using the basic Mrs-MapReduce framework

%\begin{thebibliography}{00}
%\bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.

%\end{thebibliography}

\section{CONCLUSION}
In this lab report, a simple WordCount, a TopKQuery and inverted index programs are created in python using Mrs-MapReduce. Mrs-MapReduce uses the concept of master and slave to divide the job into tasks that run parallely by the slaves to be collected by the master at the end of the program. 


\end{document}
